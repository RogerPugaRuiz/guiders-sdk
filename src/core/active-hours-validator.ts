import { ActiveHoursConfig, TimeRange } from '../types';

/**
 * üîç Active Hours Validator
 * Valida si el chat debe estar activo seg√∫n los rangos horarios configurados
 */
export class ActiveHoursValidator {
	private config: ActiveHoursConfig;

	constructor(config: ActiveHoursConfig) {
		this.config = config;
	}

	/**
	 * Verifica si el chat debe estar activo en el momento actual
	 */
	  private getEffectiveTimezone(): string {
    // Si timezone es 'auto', detectar autom√°ticamente la zona horaria del navegador
    if (this.config.timezone === 'auto') {
      try {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      } catch (error) {
        console.warn('‚ùå [ActiveHoursValidator] No se pudo detectar timezone autom√°ticamente, usando UTC:', error);
        return 'UTC';
      }
    }
    // Si no hay timezone definido, detectar autom√°ticamente
    if (!this.config.timezone) {
      try {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      } catch (error) {
        console.warn('‚ùå [ActiveHoursValidator] No se pudo detectar timezone autom√°ticamente, usando UTC:', error);
        return 'UTC';
      }
    }
    return this.config.timezone;
  }

  public isChatActive(): boolean {
		if (!this.config.enabled) {
			return true; // Si no est√° habilitado, el chat siempre est√° activo
		}

		if (!this.config.ranges || this.config.ranges.length === 0) {
			console.warn('[ActiveHoursValidator] ‚ùå No hay rangos de horarios configurados');
			return true; // Por defecto activo si no hay configuraci√≥n
		}

		const now = this.getCurrentTime();

		// Primero verificar si el d√≠a actual es v√°lido
		if (!this.isActiveDayOfWeek(now)) {
			return false;
		}

		// Verificar si la hora actual est√° dentro de alg√∫n rango
		return this.config.ranges.some(range => this.isTimeInRange(now, range));
	}

	/**
	 * Verifica si el d√≠a de la semana actual est√° activo seg√∫n la configuraci√≥n
	 */
	private isActiveDayOfWeek(currentTime: Date): boolean {
		const currentDay = currentTime.getDay() as 0 | 1 | 2 | 3 | 4 | 5 | 6;

		// Si activeDays est√° definido, usarlo
		if (this.config.activeDays && this.config.activeDays.length > 0) {
			return this.config.activeDays.includes(currentDay);
		}

		// Si excludeWeekends est√° activo, excluir s√°bado (6) y domingo (0)
		if (this.config.excludeWeekends) {
			return currentDay !== 0 && currentDay !== 6;
		}

		// Por defecto, todos los d√≠as son activos
		return true;
	}

	/**
	 * Obtiene la hora actual en la zona horaria configurada
	 */
	private getCurrentTime(): Date {
		const now = new Date();
		const effectiveTimezone = this.getEffectiveTimezone();
		
		try {
			// Crear una fecha en la zona horaria espec√≠fica
			const timeString = now.toLocaleString('en-US', { 
				timeZone: effectiveTimezone,
				hour12: false,
				year: 'numeric',
				month: '2-digit',
				day: '2-digit',
				hour: '2-digit',
				minute: '2-digit',
				second: '2-digit'
			});
			return new Date(timeString);
		} catch (error) {
			console.warn('[ActiveHoursValidator] ‚ùå Zona horaria inv√°lida:', effectiveTimezone, error);
		}
		
		return now; // Usar hora local por defecto
	}

	/**
	 * Verifica si una hora espec√≠fica est√° dentro de un rango
	 */
	private isTimeInRange(currentTime: Date, range: TimeRange): boolean {
		try {
			const currentMinutes = this.timeToMinutes(currentTime);
			const startMinutes = this.parseTimeString(range.start);
			const endMinutes = this.parseTimeString(range.end);

			// Manejar rangos que cruzan medianoche (ej: 22:00 - 06:00)
			if (startMinutes > endMinutes) {
				return currentMinutes >= startMinutes || currentMinutes <= endMinutes;
			}
			
			// Rango normal dentro del mismo d√≠a
			return currentMinutes >= startMinutes && currentMinutes <= endMinutes;
		} catch (error) {
			console.warn('[ActiveHoursValidator] ‚ùå Error validando rango:', range, error);
			return true; // En caso de error, permitir actividad
		}
	}

	/**
	 * Convierte una hora "HH:MM" a minutos desde medianoche
	 */
	private parseTimeString(timeStr: string): number {
		const match = timeStr.match(/^(\d{1,2}):(\d{2})$/);
		if (!match) {
			throw new Error(`Formato de hora inv√°lido: ${timeStr}. Use formato HH:MM`);
		}

		const hours = parseInt(match[1], 10);
		const minutes = parseInt(match[2], 10);

		if (hours < 0 || hours > 23) {
			throw new Error(`Hora inv√°lida: ${hours}. Debe estar entre 0-23`);
		}

		if (minutes < 0 || minutes > 59) {
			throw new Error(`Minutos inv√°lidos: ${minutes}. Debe estar entre 0-59`);
		}

		return hours * 60 + minutes;
	}

	/**
	 * Convierte un objeto Date a minutos desde medianoche
	 */
	private timeToMinutes(date: Date): number {
		return date.getHours() * 60 + date.getMinutes();
	}

	/**
	 * Obtiene el mensaje de fallback cuando el chat no est√° activo
	 */
	public getFallbackMessage(): string {
		if (this.config.fallbackMessage) {
			return this.config.fallbackMessage;
		}

		// Generar mensaje autom√°tico basado en la configuraci√≥n
		const now = this.getCurrentTime();
		const isValidDay = this.isActiveDayOfWeek(now);

		if (!isValidDay) {
			if (this.config.excludeWeekends) {
				return 'El chat est√° disponible solo de lunes a viernes.';
			}
			if (this.config.activeDays) {
				const dayNames = this.getActiveDayNames();
				return `El chat est√° disponible solo los d√≠as: ${dayNames}.`;
			}
		}

		return 'El chat no est√° disponible en este momento. Por favor, int√©ntalo m√°s tarde.';
	}

	/**
	 * Obtiene los nombres de los d√≠as activos en espa√±ol
	 */
	private getActiveDayNames(): string {
		if (!this.config.activeDays || this.config.activeDays.length === 0) {
			return 'todos los d√≠as';
		}

		const dayNames = ['domingo', 'lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado'];
		return this.config.activeDays
			.map(day => dayNames[day])
			.join(', ');
	}

	/**
	 * Obtiene informaci√≥n sobre el pr√≥ximo horario disponible
	 */
	public getNextAvailableTime(): string | null {
		if (!this.config.enabled || !this.config.ranges.length) {
			return null;
		}

		const now = this.getCurrentTime();
		const currentMinutes = this.timeToMinutes(now);
		
		// Buscar el pr√≥ximo horario de inicio
		let nextStart: number | null = null;
		
		for (const range of this.config.ranges) {
			try {
				const startMinutes = this.parseTimeString(range.start);
				
				// Si el horario es hoy y a√∫n no ha empezado
				if (startMinutes > currentMinutes) {
					if (nextStart === null || startMinutes < nextStart) {
						nextStart = startMinutes;
					}
				}
				// Si no hay horario hoy, usar el primer horario de ma√±ana
				else if (nextStart === null) {
					nextStart = startMinutes; // Para ma√±ana
				}
			} catch (error) {
				console.warn('[ActiveHoursValidator] ‚ùå Error procesando rango:', range, error);
			}
		}

		if (nextStart !== null) {
			const hours = Math.floor(nextStart / 60);
			const minutes = nextStart % 60;
			return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
		}

		return null;
	}

	/**
	 * Obtiene la configuraci√≥n actual
	 */
	public getConfig(): ActiveHoursConfig {
		return { ...this.config };
	}

	/**
	 * Valida la configuraci√≥n de horarios activos
	 */
	public static validateConfig(config: ActiveHoursConfig): string[] {
		const errors: string[] = [];

		if (config.enabled) {
			if (!config.ranges || !Array.isArray(config.ranges)) {
				errors.push('Se requiere un array de rangos horarios cuando activeHours est√° habilitado');
			} else if (config.ranges.length === 0) {
				errors.push('Se requiere al menos un rango horario');
			} else {
				// Validar cada rango
				config.ranges.forEach((range, index) => {
					if (!range.start || !range.end) {
						errors.push(`Rango ${index + 1}: Se requieren propiedades 'start' y 'end'`);
						return;
					}

					try {
						const validator = new ActiveHoursValidator({ enabled: true, ranges: [] });
						validator.parseTimeString(range.start);
						validator.parseTimeString(range.end);
					} catch (error) {
						const message = error instanceof Error ? error.message : String(error);
						errors.push(`Rango ${index + 1}: ${message}`);
					}
				});
			}

			// Validar zona horaria si est√° presente
			if (config.timezone && config.timezone !== 'auto') {
				try {
					new Date().toLocaleString('en-US', { timeZone: config.timezone });
				} catch (error) {
					const message = error instanceof Error ? error.message : String(error);
					errors.push(`Zona horaria inv√°lida: ${config.timezone} - ${message}`);
				}
			}

			// Validar activeDays si est√° presente
			if (config.activeDays) {
				if (!Array.isArray(config.activeDays)) {
					errors.push('activeDays debe ser un array de n√∫meros');
				} else if (config.activeDays.length === 0) {
					errors.push('activeDays no puede estar vac√≠o. Si quieres todos los d√≠as, omite esta propiedad');
				} else {
					const invalidDays = config.activeDays.filter(day => day < 0 || day > 6 || !Number.isInteger(day));
					if (invalidDays.length > 0) {
						errors.push(`activeDays contiene valores inv√°lidos: ${invalidDays.join(', ')}. Use n√∫meros entre 0 (domingo) y 6 (s√°bado)`);
					}
				}
			}

			// Advertir si se usan ambos excludeWeekends y activeDays
			if (config.excludeWeekends && config.activeDays && config.activeDays.length > 0) {
				errors.push('No use excludeWeekends y activeDays al mismo tiempo. activeDays tiene prioridad');
			}
		}

		return errors;
	}
}

/**
 * Funci√≥n de utilidad para crear una configuraci√≥n de horarios activos
 */
export function createActiveHoursConfig(
	ranges: { start: string; end: string }[],
	options: {
		timezone?: string;
		fallbackMessage?: string;
	} = {}
): ActiveHoursConfig {
	return {
		enabled: true,
		ranges,
		timezone: options.timezone,
		fallbackMessage: options.fallbackMessage
	};
}

/**
 * Configuraciones predefinidas comunes
 */
export const COMMON_ACTIVE_HOURS = {
	/**
	 * Horario comercial est√°ndar: 9:00 - 18:00, todos los d√≠as
	 */
	BUSINESS_HOURS: createActiveHoursConfig([
		{ start: '09:00', end: '18:00' }
	]),

	/**
	 * Horario comercial de lunes a viernes: 9:00 - 18:00
	 */
	BUSINESS_HOURS_WEEKDAYS: {
		enabled: true,
		ranges: [{ start: '09:00', end: '18:00' }],
		excludeWeekends: true,
		fallbackMessage: 'El chat est√° disponible de lunes a viernes de 9:00 a 18:00'
	},

	/**
	 * Horario partido (ej: Espa√±a): 8:00 - 14:00 y 15:00 - 17:00
	 */
	SPLIT_SCHEDULE: createActiveHoursConfig([
		{ start: '08:00', end: '14:00' },
		{ start: '15:00', end: '17:00' }
	]),

	/**
	 * Horario partido de lunes a viernes
	 */
	SPLIT_SCHEDULE_WEEKDAYS: {
		enabled: true,
		ranges: [
			{ start: '08:00', end: '14:00' },
			{ start: '15:00', end: '17:00' }
		],
		excludeWeekends: true,
		fallbackMessage: 'El chat est√° disponible de lunes a viernes de 8:00-14:00 y 15:00-17:00'
	},

	/**
	 * Horario extendido: 7:00 - 22:00, todos los d√≠as
	 */
	EXTENDED_HOURS: createActiveHoursConfig([
		{ start: '07:00', end: '22:00' }
	]),

	/**
	 * Horario extendido de lunes a viernes
	 */
	EXTENDED_HOURS_WEEKDAYS: {
		enabled: true,
		ranges: [{ start: '07:00', end: '22:00' }],
		excludeWeekends: true,
		fallbackMessage: 'El chat est√° disponible de lunes a viernes de 7:00 a 22:00'
	},

	/**
	 * Turno de noche: 22:00 - 06:00 (cruza medianoche)
	 */
	NIGHT_SHIFT: createActiveHoursConfig([
		{ start: '22:00', end: '06:00' }
	]),

	/**
	 * Solo fines de semana: 10:00 - 20:00
	 */
	WEEKENDS_ONLY: {
		enabled: true,
		ranges: [{ start: '10:00', end: '20:00' }],
		activeDays: [0, 6], // Domingo y s√°bado
		fallbackMessage: 'El chat est√° disponible solo los fines de semana de 10:00 a 20:00'
	},

	/**
	 * Horario personalizado: Lunes, Mi√©rcoles, Viernes
	 */
	MWF_ONLY: {
		enabled: true,
		ranges: [{ start: '09:00', end: '17:00' }],
		activeDays: [1, 3, 5], // Lunes, Mi√©rcoles, Viernes
		fallbackMessage: 'El chat est√° disponible lunes, mi√©rcoles y viernes de 9:00 a 17:00'
	}
};