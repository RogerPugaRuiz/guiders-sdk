<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E2E Test - CreateChat V2 API</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 1000px; 
            margin: 20px auto; 
            padding: 20px; 
            background: #f5f5f5;
        }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .status { padding: 12px; margin: 8px 0; border-radius: 6px; border-left: 4px solid; }
        .pass { background: #d4edda; color: #155724; border-left-color: #28a745; }
        .fail { background: #f8d7da; color: #721c24; border-left-color: #dc3545; }
        .info { background: #d1ecf1; color: #0c5460; border-left-color: #17a2b8; }
        .warning { background: #fff3cd; color: #856404; border-left-color: #ffc107; }
        .running { background: #e2e3e5; color: #383d41; border-left-color: #6c757d; }
        
        button { 
            background: #007cba; 
            color: white; 
            border: none; 
            padding: 12px 20px; 
            border-radius: 6px; 
            cursor: pointer; 
            margin: 5px; 
            font-size: 14px;
            font-weight: 500;
        }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        button:hover:not(:disabled) { background: #0056b3; }
        
        .test-section { 
            border: 1px solid #dee2e6; 
            margin: 20px 0; 
            padding: 20px; 
            border-radius: 8px; 
            background: #f8f9fa;
        }
        
        pre { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 6px; 
            font-size: 12px; 
            overflow-x: auto; 
            border: 1px solid #e9ecef;
            margin: 10px 0;
        }
        
        .test-summary {
            background: #e9ecef;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
        }
        
        .test-case {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            margin: 10px 0;
            padding: 15px;
        }
        
        .test-case h4 {
            margin: 0 0 10px 0;
            color: #495057;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #28a745;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .test-stats {
            display: flex;
            gap: 20px;
            margin: 15px 0;
        }
        
        .stat {
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            min-width: 80px;
        }
        
        .stat-total { background: #e2e3e5; }
        .stat-pass { background: #d4edda; color: #155724; }
        .stat-fail { background: #f8d7da; color: #721c24; }
        .stat-skip { background: #fff3cd; color: #856404; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ E2E Test - CreateChat V2 API</h1>
        
        <div class="info">
            <h3>Comprehensive End-to-End Test Suite</h3>
            <p>This test validates the complete functionality of the new PUT endpoint for chat creation including:</p>
            <ul>
                <li><strong>Idempotency:</strong> Same chat ID returns existing chat</li>
                <li><strong>Status Codes:</strong> 201 for new chats, 200 for existing</li>
                <li><strong>Data Validation:</strong> All required fields and structure</li>
                <li><strong>Error Handling:</strong> Invalid requests and edge cases</li>
                <li><strong>Integration:</strong> Full SDK workflow validation</li>
            </ul>
        </div>

        <div class="test-summary">
            <h3>üìä Test Progress</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
            <div class="test-stats">
                <div class="stat stat-total">
                    <div><strong id="totalTests">0</strong></div>
                    <div>Total</div>
                </div>
                <div class="stat stat-pass">
                    <div><strong id="passedTests">0</strong></div>
                    <div>Passed</div>
                </div>
                <div class="stat stat-fail">
                    <div><strong id="failedTests">0</strong></div>
                    <div>Failed</div>
                </div>
                <div class="stat stat-skip">
                    <div><strong id="skippedTests">0</strong></div>
                    <div>Skipped</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>üéÆ Test Controls</h3>
            <button onclick="runAllTests()" id="runAllBtn">üèÉ‚Äç‚ôÇÔ∏è Run All E2E Tests</button>
            <button onclick="runSingleTest()" id="runSingleBtn">üéØ Run Single Test</button>
            <button onclick="clearResults()" id="clearBtn">üßπ Clear Results</button>
            <button onclick="exportResults()" id="exportBtn" disabled>üì§ Export Results</button>
        </div>

        <div id="testResults"></div>
    </div>

    <script src="dist/index.js"></script>
    <script>
        class E2ETestSuite {
            constructor() {
                this.chatService = null;
                this.testResults = [];
                this.currentTestIndex = 0;
                this.totalTests = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                this.skippedTests = 0;
                this.isRunning = false;
                
                this.testCases = [
                    {
                        name: "Initialize ChatV2Service",
                        description: "Verify SDK initialization and service availability",
                        test: this.testInitialization.bind(this)
                    },
                    {
                        name: "Create New Chat - Valid Data",
                        description: "Create a new chat with valid data and verify 201 status",
                        test: this.testCreateNewChat.bind(this)
                    },
                    {
                        name: "Idempotency Test - Same Chat ID",
                        description: "Create same chat again and verify 200 status with identical data",
                        test: this.testIdempotency.bind(this)
                    },
                    {
                        name: "Create Chat - Different Priority Levels",
                        description: "Test chat creation with different priority levels",
                        test: this.testDifferentPriorities.bind(this)
                    },
                    {
                        name: "Create Chat - Different Departments",
                        description: "Test chat creation with different departments",
                        test: this.testDifferentDepartments.bind(this)
                    },
                    {
                        name: "Create Chat - Optional Fields",
                        description: "Test chat creation with optional fields (tags, custom metadata)",
                        test: this.testOptionalFields.bind(this)
                    },
                    {
                        name: "Error Handling - Invalid Chat Data",
                        description: "Test error handling with invalid/missing required fields",
                        test: this.testErrorHandling.bind(this)
                    },
                    {
                        name: "Concurrent Request Handling",
                        description: "Test multiple simultaneous requests for same chat ID",
                        test: this.testConcurrentRequests.bind(this)
                    },
                    {
                        name: "Large Payload Test",
                        description: "Test with large metadata and visitor info objects",
                        test: this.testLargePayload.bind(this)
                    },
                    {
                        name: "Integration Test - Full Flow",
                        description: "Complete workflow: create chat, verify, retrieve, validate consistency",
                        test: this.testFullIntegration.bind(this)
                    }
                ];
                
                this.totalTests = this.testCases.length;
                this.updateStats();
            }

            async initialize() {
                this.log("üîß Initializing E2E Test Suite...", 'info');
                
                // Wait for SDK to be ready
                await this.waitForSDK();
                
                if (window.guiders && window.ChatV2Service) {
                    this.chatService = window.ChatV2Service.getInstance();
                    this.log("‚úÖ Test Suite initialized successfully", 'pass');
                    return true;
                } else {
                    this.log("‚ùå Failed to initialize ChatV2Service", 'fail');
                    return false;
                }
            }

            async waitForSDK() {
                return new Promise((resolve) => {
                    const checkSDK = () => {
                        if (window.guiders && window.ChatV2Service) {
                            resolve();
                        } else {
                            setTimeout(checkSDK, 500);
                        }
                    };
                    checkSDK();
                });
            }

            generateTestData(suffix = '') {
                const timestamp = Date.now();
                const randomId = Math.random().toString(36).substring(2, 8);
                
                return {
                    chatId: `e2e-chat-${timestamp}-${randomId}${suffix}`,
                    chatData: {
                        visitorInfo: {
                            id: `e2e-visitor-${timestamp}-${randomId}`,
                            name: `Test User ${suffix || randomId}`,
                            email: `test-${randomId}@e2e-test.com`,
                            phone: `+1-555-${randomId}`,
                            location: `Test City ${suffix || randomId}`,
                            additionalData: {
                                testMode: true,
                                timestamp: timestamp,
                                userAgent: navigator.userAgent
                            }
                        },
                        metadata: {
                            department: 'e2e-test',
                            source: 'automated-test',
                            initialUrl: window.location.href,
                            userAgent: navigator.userAgent,
                            referrer: document.referrer,
                            tags: {
                                testSuite: 'e2e',
                                timestamp: timestamp,
                                environment: 'test'
                            },
                            customFields: {
                                testCase: 'createChatE2E',
                                iteration: suffix || randomId
                            }
                        },
                        priority: 'NORMAL',
                        department: 'e2e-test',
                        tags: ['e2e', 'automated', 'create-chat']
                    }
                };
            }

            async runAllTests() {
                if (this.isRunning) {
                    this.log("‚ö†Ô∏è Tests are already running", 'warning');
                    return;
                }

                this.isRunning = true;
                this.clearResults();
                
                document.getElementById('runAllBtn').disabled = true;
                document.getElementById('runSingleBtn').disabled = true;
                
                this.log("üöÄ Starting E2E Test Suite...", 'info');
                
                const startTime = Date.now();
                
                for (let i = 0; i < this.testCases.length; i++) {
                    this.currentTestIndex = i;
                    const testCase = this.testCases[i];
                    
                    this.log(`üìù Running: ${testCase.name}`, 'running');
                    this.log(`   ${testCase.description}`, 'info');
                    
                    try {
                        const result = await testCase.test();
                        
                        if (result.success) {
                            this.passedTests++;
                            this.log(`‚úÖ PASSED: ${testCase.name}`, 'pass');
                            if (result.message) {
                                this.log(`   ${result.message}`, 'info');
                            }
                        } else {
                            this.failedTests++;
                            this.log(`‚ùå FAILED: ${testCase.name}`, 'fail');
                            this.log(`   Error: ${result.error}`, 'fail');
                        }
                        
                        this.testResults.push({
                            name: testCase.name,
                            success: result.success,
                            error: result.error,
                            message: result.message,
                            duration: result.duration,
                            timestamp: new Date().toISOString()
                        });
                        
                    } catch (error) {
                        this.failedTests++;
                        this.log(`üí• EXCEPTION: ${testCase.name}`, 'fail');
                        this.log(`   ${error.message}`, 'fail');
                        
                        this.testResults.push({
                            name: testCase.name,
                            success: false,
                            error: error.message,
                            duration: 0,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    this.updateStats();
                    this.updateProgress();
                    
                    // Small delay between tests for readability
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                const totalTime = Date.now() - startTime;
                const successRate = ((this.passedTests / this.totalTests) * 100).toFixed(1);
                
                this.log(`üèÅ Test Suite Completed!`, 'info');
                this.log(`   Duration: ${(totalTime / 1000).toFixed(2)}s`, 'info');
                this.log(`   Success Rate: ${successRate}%`, successRate === '100.0' ? 'pass' : 'warning');
                
                document.getElementById('exportBtn').disabled = false;
                document.getElementById('runAllBtn').disabled = false;
                document.getElementById('runSingleBtn').disabled = false;
                
                this.isRunning = false;
            }

            async runSingleTest() {
                if (!this.chatService) {
                    await this.initialize();
                }
                
                const testData = this.generateTestData('single');
                
                this.log("üéØ Running Single Test - Create Chat", 'info');
                
                try {
                    const result = await this.chatService.createChat(testData.chatId, testData.chatData);
                    this.log("‚úÖ Single test completed successfully", 'pass');
                    this.log(`   Chat ID: ${result.id}`, 'info');
                    this.log(`   Status: ${result.status}`, 'info');
                    
                    this.displayChatDetails(result, 'Single Test Result');
                    
                } catch (error) {
                    this.log(`‚ùå Single test failed: ${error.message}`, 'fail');
                }
            }

            // Test Case Implementations
            async testInitialization() {
                const startTime = Date.now();
                
                try {
                    if (!this.chatService) {
                        const initialized = await this.initialize();
                        if (!initialized) {
                            return {
                                success: false,
                                error: "Failed to initialize ChatV2Service",
                                duration: Date.now() - startTime
                            };
                        }
                    }
                    
                    return {
                        success: true,
                        message: "ChatV2Service initialized successfully",
                        duration: Date.now() - startTime
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        duration: Date.now() - startTime
                    };
                }
            }

            async testCreateNewChat() {
                const startTime = Date.now();
                
                try {
                    const testData = this.generateTestData('new');
                    const result = await this.chatService.createChat(testData.chatId, testData.chatData);
                    
                    // Validate result structure
                    if (!result.id || !result.status || !result.visitorInfo) {
                        return {
                            success: false,
                            error: "Invalid response structure",
                            duration: Date.now() - startTime
                        };
                    }
                    
                    // Store for idempotency test
                    this.lastCreatedChat = { chatId: testData.chatId, chatData: testData.chatData, result };
                    
                    return {
                        success: true,
                        message: `Chat created successfully: ${result.id}`,
                        duration: Date.now() - startTime
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        duration: Date.now() - startTime
                    };
                }
            }

            async testIdempotency() {
                const startTime = Date.now();
                
                try {
                    if (!this.lastCreatedChat) {
                        return {
                            success: false,
                            error: "No previous chat to test idempotency",
                            duration: Date.now() - startTime
                        };
                    }
                    
                    const { chatId, chatData, result: originalResult } = this.lastCreatedChat;
                    
                    // Create same chat again
                    const result = await this.chatService.createChat(chatId, chatData);
                    
                    // Validate idempotency
                    if (result.id !== originalResult.id) {
                        return {
                            success: false,
                            error: `Different chat returned: ${result.id} vs ${originalResult.id}`,
                            duration: Date.now() - startTime
                        };
                    }
                    
                    return {
                        success: true,
                        message: `Idempotency verified: Same chat returned (${result.id})`,
                        duration: Date.now() - startTime
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        duration: Date.now() - startTime
                    };
                }
            }

            async testDifferentPriorities() {
                const startTime = Date.now();
                const priorities = ['LOW', 'MEDIUM', 'NORMAL', 'HIGH', 'URGENT'];
                
                try {
                    for (const priority of priorities) {
                        const testData = this.generateTestData(`priority-${priority.toLowerCase()}`);
                        testData.chatData.priority = priority;
                        
                        const result = await this.chatService.createChat(testData.chatId, testData.chatData);
                        
                        if (result.priority !== priority) {
                            return {
                                success: false,
                                error: `Priority mismatch: expected ${priority}, got ${result.priority}`,
                                duration: Date.now() - startTime
                            };
                        }
                    }
                    
                    return {
                        success: true,
                        message: `All priority levels tested successfully: ${priorities.join(', ')}`,
                        duration: Date.now() - startTime
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        duration: Date.now() - startTime
                    };
                }
            }

            async testDifferentDepartments() {
                const startTime = Date.now();
                const departments = ['ventas', 'soporte', 'general', 'tecnico', 'e2e-test'];
                
                try {
                    for (const department of departments) {
                        const testData = this.generateTestData(`dept-${department}`);
                        testData.chatData.department = department;
                        testData.chatData.metadata.department = department;
                        
                        const result = await this.chatService.createChat(testData.chatId, testData.chatData);
                        
                        if (result.department !== department) {
                            return {
                                success: false,
                                error: `Department mismatch: expected ${department}, got ${result.department}`,
                                duration: Date.now() - startTime
                            };
                        }
                    }
                    
                    return {
                        success: true,
                        message: `All departments tested successfully: ${departments.join(', ')}`,
                        duration: Date.now() - startTime
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        duration: Date.now() - startTime
                    };
                }
            }

            async testOptionalFields() {
                const startTime = Date.now();
                
                try {
                    const testData = this.generateTestData('optional');
                    
                    // Add extensive optional fields
                    testData.chatData.tags = ['optional-test', 'e2e', 'comprehensive'];
                    testData.chatData.visitorInfo.additionalData = {
                        browserVersion: navigator.userAgent,
                        screenResolution: `${screen.width}x${screen.height}`,
                        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                        language: navigator.language
                    };
                    testData.chatData.metadata.customFields = {
                        testType: 'optional-fields',
                        complexity: 'high',
                        dataSize: 'large'
                    };
                    
                    const result = await this.chatService.createChat(testData.chatId, testData.chatData);
                    
                    // Validate optional fields are preserved
                    if (!result.tags || !result.tags.includes('optional-test')) {
                        return {
                            success: false,
                            error: "Optional tags not preserved",
                            duration: Date.now() - startTime
                        };
                    }
                    
                    return {
                        success: true,
                        message: "Optional fields preserved correctly",
                        duration: Date.now() - startTime
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        duration: Date.now() - startTime
                    };
                }
            }

            async testErrorHandling() {
                const startTime = Date.now();
                
                try {
                    // Test with missing required fields
                    const invalidData = {
                        visitorInfo: {
                            // Missing required fields
                        },
                        metadata: {
                            // Missing required fields
                        }
                    };
                    
                    try {
                        await this.chatService.createChat('invalid-chat-test', invalidData);
                        return {
                            success: false,
                            error: "Expected error for invalid data but request succeeded",
                            duration: Date.now() - startTime
                        };
                    } catch (expectedError) {
                        // This is expected behavior
                        return {
                            success: true,
                            message: `Error handling working correctly: ${expectedError.message}`,
                            duration: Date.now() - startTime
                        };
                    }
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        duration: Date.now() - startTime
                    };
                }
            }

            async testConcurrentRequests() {
                const startTime = Date.now();
                
                try {
                    const testData = this.generateTestData('concurrent');
                    
                    // Make 3 concurrent requests for the same chat
                    const promises = Array(3).fill().map(() => 
                        this.chatService.createChat(testData.chatId, testData.chatData)
                    );
                    
                    const results = await Promise.all(promises);
                    
                    // All results should have the same chat ID
                    const allSameId = results.every(result => result.id === results[0].id);
                    
                    if (!allSameId) {
                        return {
                            success: false,
                            error: "Concurrent requests returned different chat IDs",
                            duration: Date.now() - startTime
                        };
                    }
                    
                    return {
                        success: true,
                        message: `Concurrent requests handled correctly: ${results[0].id}`,
                        duration: Date.now() - startTime
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        duration: Date.now() - startTime
                    };
                }
            }

            async testLargePayload() {
                const startTime = Date.now();
                
                try {
                    const testData = this.generateTestData('large');
                    
                    // Create large payload
                    const largeData = Array(100).fill().map((_, i) => `data-${i}`);
                    testData.chatData.metadata.customFields = {
                        largeArray: largeData,
                        largeString: 'x'.repeat(1000),
                        nestedObject: {
                            level1: {
                                level2: {
                                    level3: largeData
                                }
                            }
                        }
                    };
                    
                    const result = await this.chatService.createChat(testData.chatId, testData.chatData);
                    
                    return {
                        success: true,
                        message: `Large payload handled successfully: ${result.id}`,
                        duration: Date.now() - startTime
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        duration: Date.now() - startTime
                    };
                }
            }

            async testFullIntegration() {
                const startTime = Date.now();
                
                try {
                    const testData = this.generateTestData('integration');
                    
                    // Step 1: Create chat
                    const createdChat = await this.chatService.createChat(testData.chatId, testData.chatData);
                    
                    // Step 2: Retrieve the same chat by ID
                    const retrievedChat = await this.chatService.getChatById(createdChat.id);
                    
                    // Step 3: Validate consistency
                    if (createdChat.id !== retrievedChat.id) {
                        return {
                            success: false,
                            error: "Chat ID mismatch between create and retrieve",
                            duration: Date.now() - startTime
                        };
                    }
                    
                    if (createdChat.visitorInfo.email !== retrievedChat.visitorInfo.email) {
                        return {
                            success: false,
                            error: "Visitor email mismatch between create and retrieve",
                            duration: Date.now() - startTime
                        };
                    }
                    
                    // Step 4: Test idempotency again
                    const idempotentChat = await this.chatService.createChat(testData.chatId, testData.chatData);
                    
                    if (idempotentChat.id !== createdChat.id) {
                        return {
                            success: false,
                            error: "Idempotency failed in full integration test",
                            duration: Date.now() - startTime
                        };
                    }
                    
                    return {
                        success: true,
                        message: `Full integration test completed: Create ‚Üí Retrieve ‚Üí Idempotency ‚Üí ${createdChat.id}`,
                        duration: Date.now() - startTime
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        duration: Date.now() - startTime
                    };
                }
            }

            // Utility Methods
            updateStats() {
                document.getElementById('totalTests').textContent = this.totalTests;
                document.getElementById('passedTests').textContent = this.passedTests;
                document.getElementById('failedTests').textContent = this.failedTests;
                document.getElementById('skippedTests').textContent = this.skippedTests;
            }

            updateProgress() {
                const progress = ((this.passedTests + this.failedTests) / this.totalTests) * 100;
                document.getElementById('progressBar').style.width = `${progress}%`;
            }

            log(message, type) {
                const timestamp = new Date().toLocaleTimeString();
                const statusDiv = document.createElement('div');
                statusDiv.className = `status ${type}`;
                statusDiv.innerHTML = `[${timestamp}] ${message}`;
                document.getElementById('testResults').appendChild(statusDiv);
                
                // Scroll to bottom
                statusDiv.scrollIntoView({ behavior: 'smooth' });
                
                // Also log to console
                console.log(`[E2E] ${message}`);
            }

            displayChatDetails(chat, title = 'Chat Details') {
                const detailsHtml = `
                    <div class="test-case">
                        <h4>üìã ${title}</h4>
                        <pre>${JSON.stringify(chat, null, 2)}</pre>
                    </div>
                `;
                
                const detailsDiv = document.createElement('div');
                detailsDiv.innerHTML = detailsHtml;
                document.getElementById('testResults').appendChild(detailsDiv);
            }

            clearResults() {
                document.getElementById('testResults').innerHTML = '';
                this.testResults = [];
                this.passedTests = 0;
                this.failedTests = 0;
                this.skippedTests = 0;
                this.updateStats();
                this.updateProgress();
                document.getElementById('exportBtn').disabled = true;
            }

            exportResults() {
                const results = {
                    summary: {
                        total: this.totalTests,
                        passed: this.passedTests,
                        failed: this.failedTests,
                        skipped: this.skippedTests,
                        successRate: ((this.passedTests / this.totalTests) * 100).toFixed(1),
                        timestamp: new Date().toISOString()
                    },
                    testCases: this.testResults
                };
                
                const dataStr = JSON.stringify(results, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `e2e-test-results-${Date.now()}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
                
                this.log("üì§ Test results exported successfully", 'info');
            }
        }

        // Global test suite instance
        let testSuite = null;

        // Global functions for buttons
        async function runAllTests() {
            if (!testSuite) {
                testSuite = new E2ETestSuite();
            }
            await testSuite.runAllTests();
        }

        async function runSingleTest() {
            if (!testSuite) {
                testSuite = new E2ETestSuite();
            }
            await testSuite.runSingleTest();
        }

        function clearResults() {
            if (testSuite) {
                testSuite.clearResults();
            }
        }

        function exportResults() {
            if (testSuite) {
                testSuite.exportResults();
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            testSuite = new E2ETestSuite();
            
            // Auto-initialize after a short delay
            setTimeout(async () => {
                await testSuite.initialize();
            }, 1000);
        });
    </script>
</body>
</html>